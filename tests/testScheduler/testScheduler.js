const schd = require('../../src/scheduler/scheduler');
const options = require('../../src/extractor/options');
const extractorAPI = require('../../src/extractor/api');
const nfsErrors = require('../../src/errors/newsfeelServiceErrors');

test('Get URLs to extract.', async () => {
    let scheduler = new schd.Scheduler(
        undefined,
        "tests/testScheduler/test.extractor.properties"
    );
    scheduler.nfsCommunicator = {
        getNewUrls: async (urls) => {
            if (urls.filter((url) => url == "trigger_error").length == 1) {
                throw new nfsErrors.NewsFeelServiceHTTPError();
            }

            let result = [];
            urls.forEach((url) => {
                if (!url.startsWith("existing")) {
                    result.push(url)
                }
            });

            return Promise.resolve(result);
        }
    };
    let siteMap = {ignoreLinks: ["non-existing-ignore1", "ignore2"]};
    let page = {
        extractLinks: async () => Promise.resolve(["existing1", "non-existing-ignore1", "ignore2", "non-existing1", "non-existing2", "existing2"]),
        origin: () => 'non-existing'
    };
    let urls = await scheduler.getUrlsToExtract(page, siteMap);
    expect(urls.length).toBe(2);
    expect(urls.filter((url) => url.startsWith("non-existing")).length).toBe(2);

    page = {
        extractLinks: async () => Promise.resolve(["existing1", "ignore1", "ignore2", "non-existing1", "non-existing2", "trigger_error"]),
        origin: () => 'existing'
    };
    urls = await scheduler.getUrlsToExtract(page, siteMap);
    expect(urls.length).toBe(0);
});

test('Extract data', async () =>  {
    siteMap = { ignoreLinks: ["ignore1", "ignore2"], sourceName: 'test' };
    options.SourceOptions.fromYAML = (_) => siteMap;

    let scheduler = new schd.Scheduler(
        {
            getNewsfeelPageFor: async (_) => {}
        },
        "tests/testScheduler/test.extractor.properties"
    );
    scheduler.nfsCommunicator = undefined;

    let getNewsfeelPageForSpy = jest.spyOn(scheduler.browser, "getNewsfeelPageFor").mockImplementation(
        async (_) => {return {close: async () => {}};}
    );

    let extractFromBrowserPageSpy = jest.spyOn(extractorAPI, "extractFromBrowserPage").mockImplementation(
        async (url, _siteMap) => {
            return {
                extractTimestamp: undefined,
                url: url,
            };
        }
    );

    let extractedData = await scheduler.extractData("http://example.com#test", siteMap);
    expect(extractedData.extractTimestamp).not.toBe(undefined);
    expect(extractedData.url).toBe("http://example.com");
    expect(extractedData.rawUrl).toStrictEqual('http://example.com#test');
    expect(extractedData.sourceName).toStrictEqual('test');
    expect(getNewsfeelPageForSpy).toHaveBeenCalledTimes(1);
    expect(extractFromBrowserPageSpy).toHaveBeenCalledTimes(1);

});

test('Extract and send', async () =>  {
    let fromYAML = options.SourceOptions.fromYAML;
    siteMap = { ignoreLinks: ["ignore1", "ignore2"], sourceName: 'test'};
    options.SourceOptions.fromYAML = (_) => siteMap;
    let extractLinksSpy = undefined;
    let page = undefined;
    let initialUrls = [
        "origin-existing1", "ignore1", "ignore2", "origin-non-existing1", 
        "origin-non-existing2", "origin-existing2"];
    let triggerErrorUrls = ["ignore1", "ignore2", "origin-trigger_error", "origin-existing1"];

    let scheduler = new schd.Scheduler(
        {
            getNewsfeelPageFor: async (errorFlag) => {
                page = {
                    extractLinks: async () => Promise.resolve(errorFlag ? triggerErrorUrls : initialUrls),
                    origin: () => 'origin',
                    close: () => {},
                };
                extractLinksSpy = jest.spyOn(page, "extractLinks");
                return page;
            }
        },
        "tests/testScheduler/test.extractor.properties"
    );
    scheduler.nfsCommunicator = {
        send: async (data) => {
            if (data == "error") {
                throw new nfsErrors.NewsFeelServiceHTTPError();
            }

            return {
                ok: true,
                json: () => "Success"
            };
        },
        getNewUrls: async (urls) => {
            if (urls.filter((url) => url == "trigger_error").length == 1) {
                throw new nfsErrors.NewsFeelServiceHTTPError();
            }

            let result = [];
            urls.forEach((url) => {
                if (!url.startsWith("origin-existing")) {
                    result.push(url)
                }
            });

            return Promise.resolve(result);
        }
    };

    let getNewsfeelPageForSpy = jest.spyOn(scheduler.browser, "getNewsfeelPageFor");
    let schedulerGetUrlsToExtractSpy = jest.spyOn(scheduler, "getUrlsToExtract");

    let nfsCommunicatorGetNewUrlsSpy= jest.spyOn(scheduler.nfsCommunicator, "getNewUrls");


    let schedulerExtractDataSpy = jest.spyOn(scheduler, "extractData")
        .mockImplementation(async (url, _siteMap) => {
            let content = "example article content";
            if (url == "trigger_error") content = "error";
            return Promise.resolve(content);
        }
    );

    let nfsCommunicatorSendSpy = jest
        .spyOn(scheduler.nfsCommunicator, "send");

    // Successfull walkthrough.
    await scheduler.extractAndSend(false, undefined);
    expect(getNewsfeelPageForSpy).toHaveBeenCalledTimes(1);
    expect(getNewsfeelPageForSpy).toHaveBeenCalledWith(false);
    expect(schedulerGetUrlsToExtractSpy).toHaveBeenCalledTimes(1);
    expect(schedulerGetUrlsToExtractSpy).toHaveBeenCalledWith(page, siteMap);
    expect(extractLinksSpy).toHaveBeenCalledTimes(1);
    expect(nfsCommunicatorGetNewUrlsSpy).toHaveBeenCalledTimes(1);
    expect(nfsCommunicatorGetNewUrlsSpy)
        .toHaveBeenCalledWith(
            initialUrls.filter((url) => !url.startsWith("ignore")),
        );

    finalUrlsCount = initialUrls
        .filter((url) => url.startsWith("origin-non-existing")).length;
    expect(schedulerExtractDataSpy).toHaveBeenCalledTimes(finalUrlsCount);
    expect(schedulerExtractDataSpy)
        .toHaveBeenLastCalledWith("origin-non-existing2", siteMap);

    expect(nfsCommunicatorSendSpy).toHaveBeenCalledTimes(finalUrlsCount);
    expect(nfsCommunicatorSendSpy)
        .toHaveBeenLastCalledWith("example article content");

    // Error out while sending an article. Exercise gracefull handling of error occuring while sending separate articles data.
    await scheduler.extractAndSend(true, undefined);
    expect(nfsCommunicatorGetNewUrlsSpy).toHaveBeenCalledWith(
        triggerErrorUrls.filter((url) => !url.startsWith("ignore")),
    );
    expect(nfsCommunicatorSendSpy).toHaveBeenCalledTimes(
        finalUrlsCount + 
        triggerErrorUrls.filter((url) => url == "origin-trigger_error").length
    );

    // Restore the original function if ever needed afterwards.
    options.SourceOptions.fromYAML = fromYAML;
});
