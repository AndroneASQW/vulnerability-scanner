const testUtils = require('../utils');
const extractors = require('../../src/extractor/extractors');
const options = require('../../src/extractor/options');
const logger = require('../../src/utils/logger');
const mockNfPage = require('./mockNewsFeelPage');

afterEach(() => {
    jest.clearAllMocks();
});

async function runTest(testToRun) {
    const newsFeelPage = new mockNfPage.EmptyMockNewsfeelPage();
    const spies = {
        textSpy: jest.spyOn(newsFeelPage, 'extractText'),
        textMultipleSpy: jest.spyOn(newsFeelPage, 'extractTextMultiple'),
        attributesSpy: jest.spyOn(newsFeelPage, 'extractAttributes'),
        htmlSpy: jest.spyOn(newsFeelPage, 'extractHTML'),
        linksSpy: jest.spyOn(newsFeelPage, 'extractLinks'),
        refreshSpy: jest.spyOn(newsFeelPage, 'refresh'),
        loggerInfoSpy: jest.spyOn(logger, 'info'),
    };

    const parseOptions = new options.ParseOptions(
        {selector: 'selector', attributes: ['a1', 'a2']},
        [],
        'test',
        'test.yaml',
    );
    await testToRun(newsFeelPage, parseOptions, spies);
}

test('Test text extractor - no ignores', async () => {
    await runTest(async (newsFeelPage, parseOptions, spies) => {
        await extractors.text(newsFeelPage, parseOptions);

        expect(spies.textSpy)
            .toHaveBeenCalledTimes(1);
        expect(spies.textSpy)
            .toHaveBeenCalledWith('selector', null);
        expect(spies.refreshSpy)
            .toHaveBeenCalledTimes(1);
    });
});

test('Test text extractor - with ignores', async () => {
    await runTest(async (newsFeelPage, parseOptions, spies) => {
        parseOptions.ignore = ['a', 'b'];
        await extractors.text(newsFeelPage, parseOptions);

        expect(spies.textSpy)
            .toHaveBeenCalledTimes(1);
        expect(spies.textSpy)
            .toHaveBeenCalledWith('selector', ['a', 'b']);
        expect(spies.refreshSpy)
            .toHaveBeenCalledTimes(1);
    });
});

test('Test attributes extraction', async () => {
    await runTest(async (newsFeelPage, parseOptions, spies) => {
        await extractors.attributes(newsFeelPage, parseOptions);

        // Test the appropriate extraction functions are called.
        expect(spies.attributesSpy)
            .toHaveBeenCalledTimes(1);
        expect(spies.attributesSpy)
            .toHaveBeenCalledWith('selector', ['a1', 'a2']);
    });
});

test('Test links extraction', async () => {
    await runTest(async (newsFeelPage, parseOptions, spies) => {
        await extractors.links(newsFeelPage, parseOptions);

        expect(spies.linksSpy)
            .toHaveBeenCalledTimes(1);
        expect(spies.linksSpy)
            .toHaveBeenCalledWith('selector');
    });
});

test('Test HTML extraction', async () => {
    await runTest(async (newsFeelPage, parseOptions, spies) => {
        await extractors.raw(newsFeelPage, parseOptions);

        expect(spies.htmlSpy)
            .toHaveBeenCalledTimes(1);
        expect(spies.htmlSpy)
            .toHaveBeenCalledWith('selector');
    });
});

test('Test text extraction multiple - default separator', async () => {
    await runTest(async (newsFeelPage, parseOptions, spies) => {
        parseOptions.selectAll = true;

        await extractors.text(newsFeelPage, parseOptions);

        expect(spies.textMultipleSpy)
            .toHaveBeenCalledTimes(1);
        expect(spies.textMultipleSpy)
            .toHaveBeenCalledWith('selector', null, '\n');
        expect(spies.refreshSpy)
            .toHaveBeenCalledTimes(1);
    })
});

test('Test text extraction multiple - custom separator', async () => {
    await runTest(async (newsFeelPage, parseOptions, spies) => {
        parseOptions.selectAll = true;
        parseOptions.separator = ' ';

        await extractors.text(newsFeelPage, parseOptions);

        expect(spies.textMultipleSpy)
            .toHaveBeenCalledTimes(1);
        expect(spies.textMultipleSpy)
            .toHaveBeenCalledWith('selector', null, ' ');
        expect(spies.refreshSpy)
            .toHaveBeenCalledTimes(1);  
    })
});
