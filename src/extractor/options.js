const path = require('path');

const diskIO = require('../utils/diskIO');
const extractors = require('./extractors');
const extractionErrors = require('../errors/extractionErrors');

class SourceOptions {
    /**
     *  Source options class.
     * 
     * @param {Object} optionsData - with the parsed options information
     * @param {string} optionsFile - Path to the file the options were 
     * extracted from. Used for logging purposes.
     */
    constructor (optionsData, optionsFile) {
        this.optionsData = optionsData;
        this.ignoreLinks = this.optionsData.ignoreLinks;
        this.sourceName = this.optionsData.sourceName;
        this.homepageLinksSelector = this.optionsData.homepageLinksSelector;
        if (this.ignoreLinks === undefined) 
            this.ignoreLinks = [];
        this.parseOptions = new Array();
        this.optionsFile = path.resolve(optionsFile);
        for (let itemName of Object.keys(this.optionsData.parse)) {
            this.parseOptions.push(
                new ParseOptions(
                    this.optionsData.parse[itemName],
                    this.ignoreLinks,
                    itemName,
                    this.optionsFile,
                )
            )
        }
    }

    /**
     * Instantiate a new instance of `SourceOptions` from a given YAML file.
     *  
     * @param {string} optionsFile - Path to the file the options should
     * be extracted from.
     * 
     * @returns {SourceOptions} - The newly instantiated object.
     */
    static async fromYAML(optionsFile) {
        const data = await diskIO.parseYaml(optionsFile);
        return new SourceOptions(data, optionsFile);
    }
}

class ParseOptions {
    /**
     * 
     * Item parsing options class.
     * 
     * @param {Object} parseOptions - The parse options for this item. 
     * @param {Array<string>} ignoreLinks - List of links that should be 
     * ignored when parsing.
     * @param {string} itemName - The name of the item these options are for.
     * @param {string} sourcePath - Path to the file where these options were
     * found. Used for logging purposes.
     */
    constructor (parseOptions, ignoreLinks, itemName, sourcePath) {
        this.ignoreLinks = ignoreLinks;
        this.itemName = itemName;
        this.sourcePath = sourcePath;
        for (let key of Object.keys(parseOptions))
            this[key] = parseOptions[key];
    }

    /**
     *  Get the selector for this parse option.
     * 
     * @returns {string} The selector stored in this object.
     * 
     * @throws {extractionErrors.SelectorNotFoundError} If there's no selector
     * for this parse options.
     */
    getSelectorSafe() {
        const selector = this.selector;
        if (selector === undefined) 
            throw new extractionErrors.SelectorNotFoundError(
                this.sourcePath, this.itemName,
            );
        return selector;
    }

    /**
     * Get the value for an option stored in here.
     * 
     * @param {string} keyName - For the value we're looking for.
     * @param {Object} defaultValue - The default value that should be
     * returned if `keyName` could not be idenfied. Default `null`.
     * 
     * @returns {Object} - The value for `keyName` or `defaultValue`
     * if that could not be found.
     */
    getValue(keyName, defaultValue=null) {
        return this[keyName] ? this[keyName] : defaultValue;
    }

    /**
     * Get an extraction function for this item.
     * 
     * @returns {function} - The correct extract function for this item.
     * 
     * @throws {extractionErrors.ExtractKeyNotFoundError} If the `extract` key
     * could not be found in the options.
     * @throws {extractionErrors.ExtractionModeNotSupportedError}
     */
    getExtractionFunction() {
        const whatToExtract = this.extract;
        if (whatToExtract === undefined)
            throw new extractionErrors.ExtractKeyNotFoundError(
                this.sourcePath, this.itemName,
            );
        const extractorFn = extractors[whatToExtract];

        if (extractorFn === undefined)
            throw new extractionErrors.ExtractionModeNotSupportedError(
                this.sourcePath, this.itemName, whatToExtract,
            );

        return extractorFn;
    }

    /**
     * Get attributes to extract for this item.
     * 
     * @returns {Array<string>} - The attributes to be extracted.
     * 
     * @throws {extractionErrors.AttributesNotFoundError} If there's no 
     * `attributes` key in these parse options.
     */
    getAttributesSafe() {
        const attributes = this.attributes;
        if (attributes === undefined)
            throw new extractionErrors.AttributesNotFoundError(
                this.sourcePath, this.itemName,
            );
        return attributes;
    }
}

module.exports = {
    SourceOptions,
    ParseOptions,
}
